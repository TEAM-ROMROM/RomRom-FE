name: Android-PlayStore-Internal-Deploy

on:
  push:
    branches: ["deploy"]
  workflow_run:
    workflows: ["CHANGELOG 자동 업데이트"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

env:
  FLUTTER_VERSION: "3.27.3"
  JAVA_VERSION: "17"
  PROJECT_TYPE: "flutter"

jobs:
  prepare-build:
    name: 환경 설정 및 준비
    runs-on: ubuntu-latest
    # CHANGELOG 워크플로우가 성공한 경우에만 실행
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name != 'workflow_run' }}

    outputs:
      version: ${{ steps.current_version.outputs.version }}
      version_code: ${{ steps.current_version.outputs.version_code }}
      project_type: ${{ steps.current_version.outputs.project_type }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: deploy
          fetch-depth: 0

      - name: Pull latest changes
        run: git pull origin deploy

      - name: Create .env file
        run: |
          echo "${{ secrets.ENV_FILE }}" > .env
          echo ".env file created"

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          cache: true

      - name: Cache Flutter dependencies
        uses: actions/cache@v4
        with:
          path: ~/.pub-cache
          key: ${{ runner.os }}-flutter-pub-${{ hashFiles('**/pubspec.lock') }}
          restore-keys: ${{ runner.os }}-flutter-pub-

      - name: Install dependencies
        run: flutter pub get

      # 버전 관리 스크립트 권한 설정
      - name: 버전 관리 스크립트 권한 설정
        run: |
          chmod +x ./.github/scripts/version_manager.sh
          chmod +x ./.github/scripts/changelog_manager.py

      # version_manager.sh를 사용하여 현재 버전 정보 가져오기
      - name: 현재 버전 정보 가져오기
        id: current_version
        run: |
          # 버전 관리 스크립트로 버전 정보 가져오기
          VERSION=$(./.github/scripts/version_manager.sh get | tail -n 1)
          echo "📋 버전 정보: $VERSION"

          # Flutter 버전이 x.x.x+y 형식인지 확인
          if [[ "$VERSION" == *"+"* ]]; then
            # 기존 x.x.x+y 형식에서 빌드 번호 추출
            VERSION_NAME=$(echo "$VERSION" | cut -d'+' -f1)
            VERSION_CODE=$(echo "$VERSION" | cut -d'+' -f2)
            echo "📋 기존 형식 감지: 버전=$VERSION_NAME, 빌드코드=$VERSION_CODE"
          else
            # x.x.x 형식에서는 별도 빌드 코드 사용
            VERSION_NAME=$VERSION
          
            # Android 빌드를 위한 버전 코드 생성 (CI 환경에서는 GITHUB_RUN_NUMBER 활용)
            if [ -n "$GITHUB_RUN_NUMBER" ]; then
              VERSION_CODE=$GITHUB_RUN_NUMBER
            else
              # CI 환경이 아닌 경우 타임스탬프로 대체
              VERSION_CODE=$(date +%s | tail -c 6)
            fi
          fi

          # 결과 출력
          echo "version=$VERSION_NAME" >> $GITHUB_OUTPUT
          echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT
          echo "project_type=${{ env.PROJECT_TYPE }}" >> $GITHUB_OUTPUT

          echo "📋 현재 버전: $VERSION_NAME (버전코드: $VERSION_CODE)"
          echo "🔧 프로젝트 타입: ${{ env.PROJECT_TYPE }}"

          # 환경변수로도 설정 (스크립트에서 사용)
          echo "VERSION=$VERSION_NAME" >> $GITHUB_ENV
          echo "VERSION_CODE=$VERSION_CODE" >> $GITHUB_ENV
          echo "TODAY=$(date '+%Y-%m-%d')" >> $GITHUB_ENV
          echo "TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
          echo "PROJECT_TYPE=${{ env.PROJECT_TYPE }}" >> $GITHUB_ENV

      # CHANGELOG.json에서 릴리즈 노트 추출 - changelog_manager.py 사용
      - name: 릴리즈 노트 생성
        id: release_notes
        run: |
          VERSION="${{ steps.current_version.outputs.version }}"

          if [ -f "CHANGELOG.json" ]; then
            echo "📄 CHANGELOG.json에서 v$VERSION 릴리즈 노트 추출 중..."
            # CHANGELOG.md 생성
            python3 ./.github/scripts/changelog_manager.py generate-md

            # changelog_manager.py export로 릴리즈 노트 추출
            python3 ./.github/scripts/changelog_manager.py export --version $VERSION --output final_release_notes.txt

            if [ -s final_release_notes.txt ]; then
              echo "✅ 릴리즈 노트 추출 성공!"
              echo "📋 추출된 릴리즈 노트:"
              echo "----------------------------------------"
              cat final_release_notes.txt
              echo "----------------------------------------"
              echo "RELEASE_NOTES_FOUND=true" >> $GITHUB_ENV
            else
              echo "❌ 릴리즈 노트 추출 실패"
              echo "RELEASE_NOTES_FOUND=false" >> $GITHUB_ENV
              echo "v$VERSION 업데이트" > final_release_notes.txt
            fi
          else
            echo "⚠️ CHANGELOG.json 파일이 없습니다. 기본 릴리즈 노트를 사용합니다."
            echo "RELEASE_NOTES_FOUND=false" >> $GITHUB_ENV
            echo "v$VERSION 업데이트" > final_release_notes.txt
          fi

      # 릴리즈 노트를 아티팩트로 업로드
      - name: Upload release notes
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: final_release_notes.txt
          retention-days: 1

      # 프로젝트 파일들을 아티팩트로 업로드
      - name: Upload project files
        uses: actions/upload-artifact@v4
        with:
          name: project-files
          path: |
            .env
            pubspec.yaml
            lib/
            assets/
          retention-days: 1

  build-android:
    name: Android AAB 빌드
    runs-on: ubuntu-latest
    needs: prepare-build

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: deploy
          fetch-depth: 0

      - name: Pull latest changes
        run: git pull origin deploy

      # 프로젝트 파일들 다운로드
      - name: Download project files
        uses: actions/download-artifact@v4
        with:
          name: project-files
          path: .

      # .env 파일 확인 및 재생성 (복구 로직)
      - name: Ensure .env file exists
        run: |
          if [ ! -f .env ]; then
            echo "⚠️ .env 파일이 아티팩트에서 복원되지 않았습니다. 재생성합니다."
            echo "${{ secrets.ENV_FILE }}" > .env
          fi
          echo "✅ .env 파일 확인됨 (크기: $(wc -c < .env) bytes)"

      # Release Keystore 설정
      - name: Setup Release Keystore
        run: |
          mkdir -p android/app/keystore
          echo "${{ secrets.RELEASE_KEYSTORE_BASE64 }}" | base64 -d > android/app/keystore/key.jks
          echo "✅ Release Keystore 생성 완료"
          ls -la android/app/keystore/

      # key.properties 생성 (Release 서명 정보)
      - name: Create key.properties
        run: |
          cat > android/key.properties << EOF
          storeFile=keystore/key.jks
          storePassword=${{ secrets.RELEASE_KEYSTORE_PASSWORD }}
          keyAlias=${{ secrets.RELEASE_KEY_ALIAS }}
          keyPassword=${{ secrets.RELEASE_KEY_PASSWORD }}
          EOF
          echo "✅ key.properties 생성 완료"
          cat android/key.properties

      # Google-services.json 생성
      - name: Create Google-services.json
        run: |
          echo "${{ secrets.GOOGLE_SERVICES_JSON }}" > android/app/google-services.json
          echo "✅ Google-services.json 생성 완료"

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          cache: true

      - name: Cache Flutter dependencies
        uses: actions/cache@v4
        with:
          path: ~/.pub-cache
          key: ${{ runner.os }}-flutter-pub-${{ hashFiles('**/pubspec.lock') }}
          restore-keys: ${{ runner.os }}-flutter-pub-

      - name: Install dependencies
        run: flutter pub get

      - name: Set up Java
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: ${{ env.JAVA_VERSION }}

      - name: Cache Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/build.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      # Android build.gradle.kts 수정 (release 서명 설정)
      - name: Configure Android build for release
        run: |
          # build.gradle.kts에 release 서명 설정이 없으면 추가
          if ! grep -q "signingConfigs" android/app/build.gradle.kts; then
            echo "⚠️ build.gradle.kts에 서명 설정 추가 필요"
            # 서명 설정은 이미 되어있다고 가정 (수동으로 미리 설정해야 함)
          fi
          echo "✅ Android 빌드 설정 확인 완료"

      # pubspec.yaml 버전 업데이트 (버전정보+런타임번호 로 수정하여 빌드)
      - name: Update pubspec.yaml version
        run: |
          VERSION_NAME="${{ needs.prepare-build.outputs.version }}"
          VERSION_CODE="${{ needs.prepare-build.outputs.version_code }}"
          
          echo "📝 pubspec.yaml 버전 업데이트: ${VERSION_NAME}+${VERSION_CODE}"
          echo "🔍 수정 전 pubspec.yaml:"
          grep "^version:" pubspec.yaml
          
          # pubspec.yaml의 version 필드 업데이트
          cp pubspec.yaml pubspec.yaml.bak
          awk -v new_version="${VERSION_NAME}+${VERSION_CODE}" '/^version:/ {print "version: " new_version; next} {print}' pubspec.yaml.bak > pubspec.yaml
          
          echo "✅ 수정 후 pubspec.yaml:"
          grep "^version:" pubspec.yaml
          
          # 검증: AAB 빌드 시 사용될 버전 확인
          echo "🎯 Flutter가 인식할 버전:"
          flutter --version
          flutter pub get --offline || flutter pub get
          flutter analyze --no-fatal-infos || echo "분석 경고 무시"

      # Flutter build appbundle (AAB 생성)
      - name: Build Android App Bundle (AAB)
        run: |
          echo "🚀 AAB 빌드 시작..."
          echo "📦 빌드에 사용될 버전: ${{ needs.prepare-build.outputs.version }}+${{ needs.prepare-build.outputs.version_code }}"
          
          flutter build appbundle --release --verbose
          
          echo "✅ AAB 빌드 완료"
          ls -lh build/app/outputs/bundle/release/
          
          # AAB 파일 내부의 실제 버전 정보 확인 (중요!)
          echo "🔍 AAB 파일 내부 버전 정보 확인:"
          if command -v aapt2 &> /dev/null; then
            aapt2 dump badging build/app/outputs/bundle/release/app-release.aab 2>/dev/null | grep -E "package:|versionCode|versionName" || echo "aapt2로 확인 불가"
          else
            echo "⚠️ aapt2가 설치되어 있지 않습니다. bundletool로 확인 시도..."
          fi
          
          # bundletool로 버전 확인 (더 정확함)
          if [ -f "build/app/outputs/bundle/release/app-release.aab" ]; then
            echo "📱 AAB 파일 존재 확인: OK"
            unzip -p build/app/outputs/bundle/release/app-release.aab base/manifest/AndroidManifest.xml | strings | grep -E "versionCode|versionName" || echo "Manifest 직접 추출 시도..."
          fi

      # AAB 파일을 아티팩트로 업로드
      - name: Upload AAB artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-aab
          path: build/app/outputs/bundle/release/app-release.aab
          retention-days: 1

  deploy-playstore:
    name: Play Store 내부 테스트 배포
    runs-on: ubuntu-latest
    needs: [prepare-build, build-android]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: deploy
          fetch-depth: 0

      # Service Account JSON 설정
      - name: Setup Google Play Service Account
        run: |
          mkdir -p ~/.config/gcloud
          echo "${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON_BASE64 }}" | base64 --decode > ~/.config/gcloud/service-account.json
          echo "✅ Service Account JSON 설정 완료"

      # AAB 파일 다운로드
      - name: Download AAB artifact
        uses: actions/download-artifact@v4
        with:
          name: android-aab
          path: build/app/outputs/bundle/release/

      # 릴리즈 노트 다운로드
      - name: Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: .

      # Ruby 및 Fastlane 설치
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.4.1"

      - name: Install Fastlane
        run: |
          gem install fastlane
          echo "✅ Fastlane 설치 완료"
          fastlane --version

      # Fastfile 생성 (Play Store 배포용)
      - name: Create Fastfile for Play Store
        run: |
          mkdir -p android/fastlane
          cat > android/fastlane/Fastfile << 'EOF'
          default_platform(:android)

          platform :android do
            lane :deploy_internal do
              # Play Store 내부 테스트 트랙에 업로드
              # Changelog는 이미 metadata/android/ko-KR/changelogs/[VERSION_CODE].txt에 준비됨
              # version_code는 AAB 파일에 이미 포함되어 있으므로 별도 지정 불필요
              upload_to_play_store(
                package_name: 'com.alom.romrom',        # Android 패키지 이름
                track: 'internal',                      # 내부 테스트 트랙
                aab: ENV["AAB_PATH"],                   # AAB 파일 경로 (버전 정보 포함)
                json_key: ENV["GOOGLE_PLAY_JSON_KEY"],  # Service Account JSON 경로
                skip_upload_apk: true,                  # APK 업로드 안함
                skip_upload_metadata: true,             # 메타데이터 업로드 안함
                skip_upload_images: true,               # 이미지 업로드 안함
                skip_upload_screenshots: true,          # 스크린샷 업로드 안함
                skip_upload_changelogs: false,          # Changelog 업로드 (metadata 디렉토리에서 자동 인식)
                release_status: 'completed',            # 즉시 배포
                rollout: '1.0'                          # 100% 배포
              )

              puts "✅ Play Store 내부 테스트 배포 완료!"
              puts "버전: #{ENV['VERSION_NAME']}"
            end
          end
          EOF
          
          echo "✅ Fastfile 생성 완료"
          cat android/fastlane/Fastfile

      # Play Store에 업로드
      - name: Upload to Play Store Internal Testing
        run: |
          echo "======================================"
          echo "🚀 Play Store 배포 시작"
          echo "======================================"
          
          # AAB 파일 절대 경로 찾기
          AAB_PATH=$(realpath build/app/outputs/bundle/release/app-release.aab)
          echo "📦 AAB 파일 경로: $AAB_PATH"

          if [ ! -f "$AAB_PATH" ]; then
            echo "❌ AAB 파일을 찾을 수 없습니다!"
            echo "빌드 디렉토리 내용:"
            ls -la build/app/outputs/bundle/release/
            exit 1
          fi
          
          echo "✅ AAB 파일 존재 확인"
          ls -lh "$AAB_PATH"

          # Release notes 준비
          if [ -f "final_release_notes.txt" ]; then
            RELEASE_NOTES=$(cat final_release_notes.txt)
            echo "📝 Release Notes 포함하여 업로드:"
            echo "─────────────────────────────────"
            echo "$RELEASE_NOTES"
            echo "─────────────────────────────────"
          else
            RELEASE_NOTES="v${{ needs.prepare-build.outputs.version }} 업데이트"
            echo "⚠️ 기본 Release Notes로 업로드: $RELEASE_NOTES"
          fi

          # Fastlane이 인식할 수 있도록 changelog 파일 준비
          VERSION_CODE="${{ needs.prepare-build.outputs.version_code }}"
          VERSION_NAME="${{ needs.prepare-build.outputs.version }}"
          CHANGELOG_DIR="android/fastlane/metadata/android/ko-KR/changelogs"
          mkdir -p "$CHANGELOG_DIR"
          
          echo "📋 버전 정보:"
          echo "  - VERSION_NAME: $VERSION_NAME"
          echo "  - VERSION_CODE: $VERSION_CODE"
          
          # 이미 만들어진 final_release_notes.txt를 Fastlane 디렉토리로 복사
          if [ -f "final_release_notes.txt" ]; then
            cp final_release_notes.txt "$CHANGELOG_DIR/${VERSION_CODE}.txt"
            echo "✅ Changelog 복사 완료: $CHANGELOG_DIR/${VERSION_CODE}.txt"
          else
            echo "$RELEASE_NOTES" > "$CHANGELOG_DIR/${VERSION_CODE}.txt"
            echo "✅ Changelog 생성 완료: $CHANGELOG_DIR/${VERSION_CODE}.txt"
          fi
          
          echo "📄 생성된 Changelog 내용:"
          echo "─────────────────────────────────"
          cat "$CHANGELOG_DIR/${VERSION_CODE}.txt"
          echo "─────────────────────────────────"
          
          # 환경변수 설정
          export AAB_PATH="$AAB_PATH"
          export GOOGLE_PLAY_JSON_KEY="$HOME/.config/gcloud/service-account.json"
          export RELEASE_NOTES="$RELEASE_NOTES"
          export VERSION_NAME="$VERSION_NAME"
          export VERSION_CODE="$VERSION_CODE"
          
          # 디버깅 정보 (최종 확인)
          echo "======================================"
          echo "🔍 최종 배포 환경 확인"
          echo "======================================"
          echo "작업 디렉토리: $(pwd)"
          echo "AAB 경로: $AAB_PATH"
          echo "Service Account: $GOOGLE_PLAY_JSON_KEY"
          echo "버전: $VERSION_NAME (코드: $VERSION_CODE)"
          echo "Changelog 파일: $CHANGELOG_DIR/${VERSION_CODE}.txt"
          echo "======================================"
          
          # Fastlane 실행
          echo "🚀 Fastlane 배포 시작..."
          cd android
          fastlane deploy_internal

      # 성공 알림
      - name: Notify Play Store Upload Success
        if: success()
        run: |
          echo "✅ Play Store 내부 테스트 배포 성공!"
          echo "버전: ${{ needs.prepare-build.outputs.version }} (${{ needs.prepare-build.outputs.version_code }})"
          echo "커밋: ${{ github.sha }}"
          echo ""
          echo "📱 테스터 확인 방법:"
          echo "1. Play Console → 테스트 및 출시 → 내부 테스트"
          echo "2. 테스터에게 테스트 링크 공유"
          echo "3. https://play.google.com/console/u/0/developers/4736601601401567973/app/4972112751122062243/tracks/internal"

      - name: Notify on Failure
        if: failure()
        run: |
          echo "❌ Play Store 배포 실패!"
          echo "로그를 확인해주세요."

