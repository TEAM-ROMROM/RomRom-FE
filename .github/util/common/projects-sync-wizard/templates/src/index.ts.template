/**
 * GitHub Projects Sync Worker
 *
 * GitHub Projectsì˜ Statusê°€ ë³€ê²½ë˜ë©´ Issue Labelì„ ìë™ìœ¼ë¡œ ë™ê¸°í™”í•©ë‹ˆë‹¤.
 *
 * í™˜ê²½ ë³€ìˆ˜ (wrangler.tomlì—ì„œ ì„¤ì •):
 * - PROJECT_NUMBER: GitHub Projects ë²ˆí˜¸
 * - STATUS_FIELD: Status í•„ë“œëª… (ê¸°ë³¸ê°’: "Status")
 * - STATUS_LABELS: ë™ê¸°í™”í•  Status Label ëª©ë¡ (JSON ë°°ì—´)
 * - ORG_NAME: GitHub Organization ì´ë¦„
 *
 * Secrets (wrangler secret putìœ¼ë¡œ ì„¤ì •):
 * - GITHUB_TOKEN: GitHub Personal Access Token (repo, project ê¶Œí•œ)
 * - WEBHOOK_SECRET: GitHub Webhook ê²€ì¦ìš© ë¹„ë°€í‚¤
 */

export interface Env {
  GITHUB_TOKEN: string;
  WEBHOOK_SECRET: string;
  PROJECT_NUMBER: string;
  STATUS_FIELD: string;
  STATUS_LABELS: string;
  ORG_NAME: string;
}

// GitHub Webhook ì´ë²¤íŠ¸ íƒ€ì… ì •ì˜
interface WebhookPayload {
  action: string;
  projects_v2_item?: {
    id: number;
    node_id: string;
    project_node_id: string;
    content_node_id: string;
    content_type: string;
  };
  changes?: {
    field_value?: {
      field_node_id: string;
      field_type: string;
    };
  };
  organization?: {
    login: string;
  };
  sender?: {
    login: string;
  };
}

// GraphQL ì‘ë‹µ íƒ€ì…
interface ProjectItemResponse {
  data?: {
    node?: {
      content?: {
        number: number;
        title: string;
        labels: {
          nodes: Array<{ name: string }>;
        };
        repository: {
          name: string;
          owner: {
            login: string;
          };
        };
      };
      fieldValueByName?: {
        name?: string;
      };
    };
  };
  errors?: Array<{ message: string }>;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // POST ìš”ì²­ë§Œ ì²˜ë¦¬
    if (request.method !== 'POST') {
      return new Response('Method Not Allowed', { status: 405 });
    }

    // Webhook ì„œëª… ê²€ì¦
    const signature = request.headers.get('X-Hub-Signature-256');
    if (!signature) {
      console.log('âŒ Missing signature header');
      return new Response('Missing signature', { status: 401 });
    }

    const body = await request.text();
    const isValid = await verifySignature(body, signature, env.WEBHOOK_SECRET);
    if (!isValid) {
      console.log('âŒ Invalid signature');
      return new Response('Invalid signature', { status: 401 });
    }

    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('ğŸ”„ GitHub Projects Sync Worker');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('âœ… Webhook signature verified');

    // ì´ë²¤íŠ¸ íƒ€ì… í™•ì¸
    const event = request.headers.get('X-GitHub-Event');
    console.log(`ğŸ“Œ Event type: ${event}`);

    if (event !== 'projects_v2_item') {
      console.log('â­ï¸ Skipping non-projects_v2_item event');
      return new Response('OK - Event ignored', { status: 200 });
    }

    const payload: WebhookPayload = JSON.parse(body);
    console.log(`ğŸ“Œ Action: ${payload.action}`);

    // edited ì•¡ì…˜ë§Œ ì²˜ë¦¬ (Status ë³€ê²½)
    if (payload.action !== 'edited') {
      console.log('â­ï¸ Skipping non-edited action');
      return new Response('OK - Action ignored', { status: 200 });
    }

    // í•„ë“œ ë³€ê²½ í™•ì¸
    if (!payload.changes?.field_value) {
      console.log('â­ï¸ No field value change detected');
      return new Response('OK - No field change', { status: 200 });
    }

    const itemNodeId = payload.projects_v2_item?.node_id;
    if (!itemNodeId) {
      console.log('âŒ No item node ID found');
      return new Response('OK - No item ID', { status: 200 });
    }

    console.log(`ğŸ“Œ Processing item: ${itemNodeId}`);

    try {
      // GraphQLë¡œ í˜„ì¬ Statusì™€ Issue ì •ë³´ ì¡°íšŒ
      const itemInfo = await getProjectItemInfo(itemNodeId, env);

      if (!itemInfo?.data?.node?.content) {
        console.log('âŒ Could not get item content');
        return new Response('OK - No content', { status: 200 });
      }

      const content = itemInfo.data.node.content;
      const currentStatus = itemInfo.data.node.fieldValueByName?.name;
      const issueNumber = content.number;
      const repoName = content.repository.name;
      const repoOwner = content.repository.owner.login;
      const currentLabels = content.labels.nodes.map(l => l.name);

      console.log(`ğŸ“Œ Issue: ${repoOwner}/${repoName}#${issueNumber}`);
      console.log(`ğŸ“Œ Current Labels: ${currentLabels.join(', ')}`);
      console.log(`ğŸ“Œ New Status: "${currentStatus}"`);

      if (!currentStatus) {
        console.log('â­ï¸ No status value');
        return new Response('OK - No status', { status: 200 });
      }

      // Status Labels íŒŒì‹±
      const statusLabels: string[] = JSON.parse(env.STATUS_LABELS);

      // í˜„ì¬ ìˆëŠ” Status Label ì œê±° ëŒ€ìƒ ì°¾ê¸°
      const labelsToRemove = currentLabels.filter(label =>
        statusLabels.includes(label) && label !== currentStatus
      );

      console.log(`ğŸ—‘ï¸ Labels to remove: ${labelsToRemove.join(', ') || 'none'}`);

      // ì´ë¯¸ ë™ì¼í•œ Labelì´ ìˆìœ¼ë©´ ìŠ¤í‚µ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
      if (currentLabels.includes(currentStatus) && labelsToRemove.length === 0) {
        console.log('â­ï¸ Label already synced, skipping');
        return new Response('OK - Already synced', { status: 200 });
      }

      // Label ì œê±°
      for (const label of labelsToRemove) {
        await removeLabel(repoOwner, repoName, issueNumber, label, env);
        console.log(`  âœ… Label "${label}" ì œê±°ë¨`);
      }

      // ìƒˆ Statusê°€ statusLabelsì— í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ Label ì¶”ê°€
      if (statusLabels.includes(currentStatus) && !currentLabels.includes(currentStatus)) {
        console.log(`â• Adding label: "${currentStatus}"`);
        await addLabel(repoOwner, repoName, issueNumber, currentStatus, env);
        console.log(`  âœ… Label "${currentStatus}" ì¶”ê°€ë¨`);
      }

      console.log('ğŸ‰ Label sync completed!');
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

      return new Response('OK - Synced', { status: 200 });

    } catch (error) {
      console.error('âŒ Error:', error);
      return new Response('Internal Server Error', { status: 500 });
    }
  }
};

/**
 * Webhook ì„œëª… ê²€ì¦ (HMAC-SHA256)
 */
async function verifySignature(payload: string, signature: string, secret: string): Promise<boolean> {
  const encoder = new TextEncoder();
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );

  const signatureBytes = await crypto.subtle.sign(
    'HMAC',
    key,
    encoder.encode(payload)
  );

  const expectedSignature = 'sha256=' + Array.from(new Uint8Array(signatureBytes))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');

  // Timing-safe comparison
  if (signature.length !== expectedSignature.length) {
    return false;
  }

  let result = 0;
  for (let i = 0; i < signature.length; i++) {
    result |= signature.charCodeAt(i) ^ expectedSignature.charCodeAt(i);
  }
  return result === 0;
}

/**
 * GraphQL APIë¡œ Project Item ì •ë³´ ì¡°íšŒ
 */
async function getProjectItemInfo(nodeId: string, env: Env): Promise<ProjectItemResponse> {
  const query = `
    query($nodeId: ID!, $statusField: String!) {
      node(id: $nodeId) {
        ... on ProjectV2Item {
          content {
            ... on Issue {
              number
              title
              labels(first: 20) {
                nodes {
                  name
                }
              }
              repository {
                name
                owner {
                  login
                }
              }
            }
            ... on PullRequest {
              number
              title
              labels(first: 20) {
                nodes {
                  name
                }
              }
              repository {
                name
                owner {
                  login
                }
              }
            }
          }
          fieldValueByName(name: $statusField) {
            ... on ProjectV2ItemFieldSingleSelectValue {
              name
            }
          }
        }
      }
    }
  `;

  const response = await fetch('https://api.github.com/graphql', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${env.GITHUB_TOKEN}`,
      'Content-Type': 'application/json',
      'User-Agent': 'GitHub-Projects-Sync-Worker'
    },
    body: JSON.stringify({
      query,
      variables: {
        nodeId,
        statusField: env.STATUS_FIELD || 'Status'
      }
    })
  });

  return response.json();
}

/**
 * REST APIë¡œ Label ì¶”ê°€
 */
async function addLabel(owner: string, repo: string, issueNumber: number, label: string, env: Env): Promise<void> {
  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/labels`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.GITHUB_TOKEN}`,
        'Content-Type': 'application/json',
        'User-Agent': 'GitHub-Projects-Sync-Worker'
      },
      body: JSON.stringify({ labels: [label] })
    }
  );

  if (!response.ok) {
    const error = await response.text();
    console.error(`Failed to add label: ${error}`);
  }
}

/**
 * REST APIë¡œ Label ì œê±°
 */
async function removeLabel(owner: string, repo: string, issueNumber: number, label: string, env: Env): Promise<void> {
  const encodedLabel = encodeURIComponent(label);
  const response = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/issues/${issueNumber}/labels/${encodedLabel}`,
    {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${env.GITHUB_TOKEN}`,
        'User-Agent': 'GitHub-Projects-Sync-Worker'
      }
    }
  );

  if (!response.ok && response.status !== 404) {
    const error = await response.text();
    console.error(`Failed to remove label: ${error}`);
  }
}
