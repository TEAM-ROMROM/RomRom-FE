# ===================================================================
# Flutter Android Play Store Setup Script (Windows PowerShell)
# ===================================================================
#
# This script automatically configures the build environment for
# Android Play Store deployment in a Flutter project.
#
# ★ Wizard-First Architecture ★
# - All configuration files are generated by this wizard
# - GitHub Actions workflows use the generated files as-is
# - No modifications needed after initial setup (One-time setup)
#
# Usage:
#   powershell -ExecutionPolicy Bypass -File playstore-wizard-setup.ps1 PROJECT_PATH APPLICATION_ID KEY_ALIAS STORE_PASSWORD KEY_PASSWORD VALIDITY_DAYS CERT_CN CERT_O CERT_L CERT_C
#
# Example:
#   powershell -ExecutionPolicy Bypass -File playstore-wizard-setup.ps1 "C:\path\to\project" "com.example.app" "my-release-key" "MyPass123" "MyPass123" "99999" "My Name" "My Company" "Seoul" "KR"
# ===================================================================

param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectPath,
    
    [Parameter(Mandatory=$true)]
    [string]$ApplicationId,
    
    [Parameter(Mandatory=$true)]
    [string]$KeyAlias,
    
    [Parameter(Mandatory=$true)]
    [string]$StorePassword,
    
    [Parameter(Mandatory=$true)]
    [string]$KeyPassword,
    
    [Parameter(Mandatory=$true)]
    [int]$ValidityDays,
    
    [Parameter(Mandatory=$true)]
    [string]$CertCN,
    
    [Parameter(Mandatory=$true)]
    [string]$CertO,
    
    [Parameter(Mandatory=$true)]
    [string]$CertL,
    
    [Parameter(Mandatory=$true)]
    [string]$CertC
)

# Output functions
function Write-Step {
    param([string]$Message)
    Write-Host "> $Message" -ForegroundColor Cyan
}

function Write-Info {
    param([string]$Message)
    Write-Host "  -> $Message" -ForegroundColor Blue
}

function Write-Success {
    param([string]$Message)
    Write-Host "OK $Message" -ForegroundColor Green
}

function Write-Warning {
    param([string]$Message)
    Write-Host "WARN $Message" -ForegroundColor Yellow
}

function Write-Error {
    param([string]$Message)
    Write-Host "ERROR $Message" -ForegroundColor Red
}

# 파일을 사용 중인 프로세스 찾기 및 종료
function Stop-ProcessesUsingFile {
    param([string]$FilePath)
    
    if (-not (Test-Path $FilePath)) {
        return $false
    }
    
    Write-Info "Finding processes using file: $FilePath"
    
    # 현재 프로세스 ID 저장 (자기 자신을 종료하지 않도록)
    $currentProcessId = $PID
    $processesKilled = $false
    
    # 모든 Java/Gradle 프로세스 종료 (관리자 권한으로 실행 시 효과적)
    Write-Warning "Attempting to kill all Java/Gradle processes..."
    foreach ($procName in @("java", "javaw", "gradle", "gradlew")) {
        try {
            $procs = Get-Process -Name $procName -ErrorAction SilentlyContinue
            foreach ($proc in $procs) {
                try {
                    # 현재 프로세스는 제외
                    if ($proc.Id -eq $currentProcessId) {
                        continue
                    }
                    
                    Write-Warning "Killing $procName process: PID $($proc.Id)"
                    Stop-Process -Id $proc.Id -Force -ErrorAction Stop
                    $processesKilled = $true
                    Start-Sleep -Milliseconds 500
                } catch {
                    # 프로세스가 이미 종료되었을 수 있음
                }
            }
        } catch {
            # 프로세스가 없을 수 있음
        }
    }
    
    if ($processesKilled) {
        Write-Info "Processes killed. Waiting 5 seconds for file handles to be released..."
        Start-Sleep -Seconds 5
        return $true
    }
    
    return $false
}

# Validation
function Validate-Parameters {
    if (-not (Test-Path $ProjectPath)) {
        Write-Error "Project path does not exist: $ProjectPath"
        exit 1
    }
    
    if (-not (Test-Path (Join-Path $ProjectPath "pubspec.yaml"))) {
        Write-Error "Not a Flutter project (pubspec.yaml not found)"
        exit 1
    }
    
    if (-not (Test-Path (Join-Path $ProjectPath "android"))) {
        Write-Error "Android folder not found. Run 'flutter create .' first."
        exit 1
    }
    
    if ($ApplicationId -notmatch '^[a-z][a-z0-9_]*(\.[a-z][a-z0-9_]*)+$') {
        Write-Error "Invalid Application ID format: $ApplicationId"
        Write-Error "Example: com.example.app"
        exit 1
    }
    
    if ([string]::IsNullOrWhiteSpace($StorePassword) -or [string]::IsNullOrWhiteSpace($KeyPassword)) {
        Write-Error "Keystore password and Key password are required."
        exit 1
    }
    
    if ($CertC.Length -ne 2) {
        Write-Error "Country Code must be 2 characters: $CertC"
        exit 1
    }
}

# Find template directory
function Get-TemplateDirectory {
    $scriptDir = Split-Path -Parent $MyInvocation.ScriptName
    $templateDir = Join-Path $scriptDir "templates"
    
    if (-not (Test-Path $templateDir)) {
        Write-Error "Template directory not found: $templateDir"
        exit 1
    }
    
    Write-Info "Template directory: $templateDir"
    return $templateDir
}

# Update .gitignore
function Update-Gitignore {
    Write-Step "Updating .gitignore..."
    
    $isGitRepo = Test-Path (Join-Path $ProjectPath ".git")
    if (-not $isGitRepo) {
        Write-Info "Not a Git repository. Skipping .gitignore update."
        return $false
    }
    
    $gitignoreUpdated = $false
    
    # Root .gitignore
    $rootGitignorePath = Join-Path $ProjectPath ".gitignore"
    $rootEntries = @(
        "# Android signing",
        "android/key.properties",
        "android/app/keystore/*.jks",
        "android/app/keystore/*.keystore"
    )
    
    if (Test-Path $rootGitignorePath) {
        $content = Get-Content $rootGitignorePath -Encoding UTF8 -Raw
        foreach ($entry in $rootEntries) {
            if ($content -notmatch [regex]::Escape($entry)) {
                Add-Content $rootGitignorePath "`n$entry" -Encoding UTF8
                Write-Info "Added to root .gitignore: $entry"
                $gitignoreUpdated = $true
            }
        }
    }
    
    # Android .gitignore
    $androidGitignorePath = Join-Path $ProjectPath "android\.gitignore"
    $androidEntries = @(
        "# Android signing",
        "key.properties",
        "app/keystore/*.jks",
        "app/keystore/*.keystore"
    )
    
    if (Test-Path $androidGitignorePath) {
        $content = Get-Content $androidGitignorePath -Encoding UTF8 -Raw
        foreach ($entry in $androidEntries) {
            if ($content -notmatch [regex]::Escape($entry)) {
                Add-Content $androidGitignorePath "`n$entry" -Encoding UTF8
                $gitignoreUpdated = $true
            }
        }
        if ($gitignoreUpdated) {
            Write-Info "Added to android/.gitignore"
        }
    } else {
        $content = @"
# Android signing
key.properties
app/keystore/*.jks
app/keystore/*.keystore
"@
        Set-Content $androidGitignorePath $content -Encoding UTF8
        Write-Info "android/.gitignore created"
        $gitignoreUpdated = $true
    }
    
    if ($gitignoreUpdated) {
        Write-Success ".gitignore update complete"
    } else {
        Write-Info ".gitignore already contains all entries."
    }
    
    return $gitignoreUpdated
}

# Commit .gitignore changes
function Commit-GitignoreChanges {
    param([bool]$GitignoreUpdated)
    
    Write-Step "Committing .gitignore changes..."
    
    $isGitRepo = Test-Path (Join-Path $ProjectPath ".git")
    if (-not $isGitRepo) {
        Write-Info "Not a Git repository. Skipping commit."
        return
    }
    
    try {
        $gitCommand = Get-Command git -ErrorAction SilentlyContinue
        if (-not $gitCommand) {
            Write-Warning "Git is not installed. Skipping commit."
            return
        }
    } catch {
        Write-Warning "Git is not installed. Skipping commit."
        return
    }
    
    Push-Location $ProjectPath
    try {
        # Check if key.properties or keystore files are tracked
        $trackedKeyProps = git ls-files "android/key.properties" 2>$null
        $trackedKeystore = git ls-files "android/app/keystore/*.jks" 2>$null
        
        $needsCommit = $false
        
        if ($trackedKeyProps) {
            Write-Warning "Removing tracked key.properties from Git..."
            git rm --cached "android/key.properties" 2>$null
            $needsCommit = $true
        }
        
        if ($trackedKeystore) {
            Write-Warning "Removing tracked keystore files from Git..."
            git rm --cached "android/app/keystore/*.jks" 2>$null
            $needsCommit = $true
        }
        
        # Check for .gitignore changes
        $gitStatus = git status --porcelain ".gitignore" "android/.gitignore" 2>$null
        
        if ($gitStatus -or $needsCommit) {
            git add ".gitignore" "android/.gitignore" 2>$null
            
            $commitMessage = "chore: Update .gitignore for Android signing files"
            $commitOutput = git commit -m $commitMessage 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                Write-Success ".gitignore changes committed"
            } else {
                Write-Warning "Commit failed (already committed or no changes)"
            }
        } else {
            Write-Info ".gitignore has no changes (already committed)."
        }
    } finally {
        Pop-Location
    }
    
    if (-not $GitignoreUpdated) {
        Write-Info ".gitignore has no changes."
    }
}

# 전역 변수: keystore 생성 스킵 여부
$script:KeystoreSkipped = $false

# Create Keystore
function Create-Keystore {
    Write-Step "Creating Keystore..."
    
    $keystoreDir = Join-Path $ProjectPath "android\app\keystore"
    $keystorePath = Join-Path $keystoreDir "key.jks"
    
    if (-not (Test-Path $keystoreDir)) {
        New-Item -ItemType Directory -Path $keystoreDir -Force | Out-Null
    }
    
    if (Test-Path $keystorePath) {
        Write-Info "Existing keystore found: $keystorePath"
        Write-Info "Overwriting existing keystore..."
        
        # 기존 keystore에서 alias 삭제 시도
        Write-Info "Attempting to delete existing alias from keystore..."
        try {
            $deleteArgs = @(
                "-delete"
                "-alias", $KeyAlias
                "-keystore", $keystorePath
                "-storepass", $StorePassword
            )
            $deleteOutput = & keytool $deleteArgs 2>&1
            $deleteExitCode = $LASTEXITCODE
            
            if ($deleteExitCode -eq 0) {
                Write-Info "Existing alias deleted from keystore successfully"
            } else {
                Write-Warning "Failed to delete alias from keystore (may not exist or wrong password): $deleteOutput"
            }
        } catch {
            Write-Warning "Error deleting alias from keystore: $($_.Exception.Message)"
        }
        
        # 파일 삭제 시도
        $backupPath = "$keystorePath.bak"
        try {
            # 백업 파일이 있으면 삭제
            if (Test-Path $backupPath) {
                Remove-Item $backupPath -Force -ErrorAction SilentlyContinue
            }
            
            # Move-Item 시도
            Move-Item $keystorePath $backupPath -Force -ErrorAction Stop
            Write-Info "Existing keystore backed up: $backupPath"
        } catch {
            # 파일이 잠겨있으면 프로세스 종료 후 재시도
            Write-Warning "Failed to move keystore file. Attempting to kill processes using the file..."
            $processesKilled = Stop-ProcessesUsingFile -FilePath $keystorePath
            
            if ($processesKilled) {
                try {
                    Remove-Item $keystorePath -Force -ErrorAction Stop
                    Write-Info "Existing keystore deleted after killing processes"
                } catch {
                    Write-Error "Failed to delete keystore after killing processes: $($_.Exception.Message)"
                    Write-Error "Please manually delete the file or close programs using it: $keystorePath"
                    exit 1
                }
            } else {
                Write-Error "Failed to delete keystore file: $keystorePath"
                Write-Error "Please manually delete the file or close programs using it."
                exit 1
            }
        }
    }
    
    $dname = "CN=$CertCN, O=$CertO, L=$CertL, C=$CertC"
    
    Write-Info "Keystore information:"
    Write-Info "  - Path: $keystorePath"
    Write-Info "  - Alias: $KeyAlias"
    Write-Info "  - Validity: $ValidityDays days"
    Write-Info "  - Certificate: $dname"
    
    try {
        $keytoolArgs = @(
            "-genkeypair"
            "-v"
            "-keystore", $keystorePath
            "-alias", $KeyAlias
            "-keyalg", "RSA"
            "-keysize", "2048"
            "-validity", $ValidityDays
            "-storepass", $StorePassword
            "-keypass", $KeyPassword
            "-dname", $dname
        )
        
        $keytoolOutput = & keytool $keytoolArgs 2>&1
        $keytoolExitCode = $LASTEXITCODE
        
        if ($keytoolExitCode -eq 0 -and (Test-Path $keystorePath)) {
            Write-Success "Keystore created successfully: $keystorePath"
        } elseif ($keytoolExitCode -ne 0) {
            Write-Error "Keystore creation failed! (Exit code: $keytoolExitCode)"
            Write-Error "keytool output: $keytoolOutput"
            exit 1
        } else {
            Write-Error "Keystore creation failed! File was not created."
            Write-Error "keytool output: $keytoolOutput"
            exit 1
        }
    } catch {
        Write-Error "Error during keystore creation: $_"
        Write-Error "Error details: $($_.Exception.Message)"
        exit 1
    }
}

# Create key.properties
function Create-KeyProperties {
    Write-Step "Creating key.properties..."
    
    # keystore 생성이 스킵되었으면 key.properties도 스킵
    if ($script:KeystoreSkipped) {
        Write-Warning "key.properties creation skipped (keystore was not overwritten)"
        Write-Warning "⚠️ 기존 keystore를 사용하므로 key.properties의 비밀번호를 수동으로 확인하세요!"
        Write-Warning "   기존 keystore의 비밀번호를 android/key.properties에 입력해야 합니다."
        Write-Warning "   또는 Step 2로 돌아가서 keystore를 덮어쓰기(y)로 다시 생성하세요."
        return
    }
    
    $keyPropertiesPath = Join-Path $ProjectPath "android\key.properties"
    
    if (Test-Path $keyPropertiesPath) {
        Write-Info "Existing key.properties found. Overwriting..."
        $backupPath = "$keyPropertiesPath.bak"
        
        # 기존 파일 백업 및 삭제 시도
        try {
            # 백업 파일이 있으면 삭제
            if (Test-Path $backupPath) {
                Remove-Item $backupPath -Force -ErrorAction SilentlyContinue
            }
            
            # 백업 후 원본 삭제
            Copy-Item $keyPropertiesPath $backupPath -Force -ErrorAction Stop
            Remove-Item $keyPropertiesPath -Force -ErrorAction Stop
            Write-Info "Existing key.properties backed up: $backupPath"
        } catch {
            # 파일이 잠겨있으면 프로세스 종료 후 재시도
            Write-Warning "Failed to backup/delete key.properties. Attempting to kill processes using the file..."
            $processesKilled = Stop-ProcessesUsingFile -FilePath $keyPropertiesPath
            
            if ($processesKilled) {
                try {
                    Remove-Item $keyPropertiesPath -Force -ErrorAction Stop
                } catch {
                    Write-Error "Failed to delete key.properties after killing processes: $($_.Exception.Message)"
                    Write-Error "Please manually delete the file or close programs using it: $keyPropertiesPath"
                    exit 1
                }
            } else {
                Write-Error "Failed to delete key.properties: $keyPropertiesPath"
                Write-Error "Please manually delete the file or close programs using it."
                exit 1
            }
        }
    }
    
    $content = @"
storePassword=$StorePassword
keyPassword=$KeyPassword
keyAlias=$KeyAlias
storeFile=app/keystore/key.jks
"@
    
    # 파일 쓰기 시도
    try {
        Set-Content $keyPropertiesPath $content -Encoding UTF8 -ErrorAction Stop
    } catch {
        # 파일이 잠겨있으면 프로세스 종료 후 재시도
        Write-Warning "Failed to write key.properties. Attempting to kill processes using the file..."
        $processesKilled = Stop-ProcessesUsingFile -FilePath $keyPropertiesPath
        
        if ($processesKilled) {
            try {
                Set-Content $keyPropertiesPath $content -Encoding UTF8 -ErrorAction Stop
                Write-Info "key.properties written successfully after killing processes"
            } catch {
                Write-Error "Failed to write key.properties after killing processes: $($_.Exception.Message)"
                Write-Error "The file may still be locked. Please manually close any programs using this file and try again."
                exit 1
            }
        } else {
            Write-Error "Failed to write key.properties: $($_.Exception.Message)"
            Write-Error "The file may be locked by another process. Please close any programs using this file and try again."
            exit 1
        }
    }
    
    # 파일이 제대로 생성되었는지 확인
    if (-not (Test-Path $keyPropertiesPath)) {
        Write-Error "key.properties file was not created: $keyPropertiesPath"
        exit 1
    }
    
    # 파일 내용 확인
    $fileContent = Get-Content $keyPropertiesPath -Raw -ErrorAction SilentlyContinue
    if (-not $fileContent -or $fileContent -notmatch "storePassword") {
        Write-Error "key.properties file exists but content is invalid: $keyPropertiesPath"
        exit 1
    }
    
    Write-Success "key.properties created successfully: $keyPropertiesPath"
    Write-Info "  - Store Password: $StorePassword"
    Write-Info "  - Key Alias: $KeyAlias"
}

# Patch build.gradle.kts
function Patch-BuildGradle {
    Write-Step "Adding signing configuration to build.gradle.kts..."
    
    $gradleFile = Join-Path $ProjectPath "android\app\build.gradle.kts"
    
    if (-not (Test-Path $gradleFile)) {
        Write-Error "build.gradle.kts not found: $gradleFile"
        exit 1
    }
    
    # Backup
    Copy-Item $gradleFile "$gradleFile.bak" -Force
    Write-Info "Backup created: $gradleFile.bak"
    
    $content = Get-Content $gradleFile -Encoding UTF8 -Raw
    
    # Import block
    $importBlock = @"

// Load key.properties file
import java.util.Properties
import java.io.FileInputStream
val keystorePropertiesFile = rootProject.file("key.properties")
val keystoreProperties = Properties()
if (keystorePropertiesFile.exists()) {
    keystoreProperties.load(FileInputStream(keystorePropertiesFile))
}
"@
    
    # Add import block after plugins
    if ($content -notmatch "keystoreProperties") {
        $pattern = '(?s)(plugins\s*\{[^}]*\n\})'
        if ($content -match $pattern) {
            $content = $content -replace $pattern, ('$1' + $importBlock)
            Write-Info "key.properties loading code added"
        } else {
            Write-Warning "plugins block not found. Manual addition may be required."
        }
    }
    
    # Add signingConfigs block
    if ($content -notmatch "signingConfigs") {
        $signingConfigsBlock = @"

    signingConfigs {
        create("release") {
            keyAlias = keystoreProperties["keyAlias"] as String?
            keyPassword = keystoreProperties["keyPassword"] as String?
            storeFile = keystoreProperties["storeFile"]?.let { rootProject.file(it) }
            storePassword = keystoreProperties["storePassword"] as String?
        }
    }
"@
        
        if ($content -match "android\s*\{") {
            $pattern = '(android\s*\{)'
            $content = $content -replace $pattern, ('$1' + $signingConfigsBlock)
            Write-Info "signingConfigs block added"
        }
    } else {
        # Fix existing storeFile path if it uses file(it) instead of rootProject.file(it)
        if ($content -match 'storeFile\s*=\s*keystoreProperties\["storeFile"\]\?\.let\s*\{\s*file\(it\)\s*\}') {
            $content = $content -replace 'storeFile\s*=\s*keystoreProperties\["storeFile"\]\?\.let\s*\{\s*file\(it\)\s*\}', 'storeFile = keystoreProperties["storeFile"]?.let { rootProject.file(it) }'
            Write-Info "Fixed storeFile path to use rootProject.file(it)"
        }
    }
    
    # Add signingConfig to release buildType
    if ($content -match "buildTypes\s*\{") {
        $signingConfigPattern = 'signingConfig\s*=\s*signingConfigs'
        if ($content -notmatch $signingConfigPattern) {
            $releasePattern = '(release\s*\{)'
            if ($content -match $releasePattern) {
                $signingConfigLine = [System.Environment]::NewLine + '            signingConfig = signingConfigs.getByName("release")'
                $replacement = '$1' + $signingConfigLine
                $content = $content -replace $releasePattern, $replacement
                Write-Info "release buildType signingConfig added"
            } else {
                Write-Warning "release buildType not found. Manual addition may be required."
            }
        }
    }
    
    # Fix flutter.source to point to project root
    # Flutter Gradle plugin needs to find lib/main.dart from project root, not android/app
    if ($content -match "flutter\s*\{") {
        # Check if source is already set to "../.."
        if ($content -notmatch 'flutter\s*\{\s*[^}]*source\s*=\s*"\.\.\/\.\."') {
            # Replace source = "." with source = "../.."
            if ($content -match 'flutter\s*\{[^}]*source\s*=\s*"\."') {
                $content = $content -replace '(flutter\s*\{[^}]*source\s*=\s*)"\."', '$1"../.."'
                Write-Info "flutter.source updated to '../..' (project root)"
            } elseif ($content -match 'flutter\s*\{') {
                # Add source if flutter block exists but source is not set
                $content = $content -replace '(flutter\s*\{)', '$1' + [System.Environment]::NewLine + '    source = "../.."'
                Write-Info "flutter.source added as '../..' (project root)"
            }
        }
    }
    
    Set-Content $gradleFile $content -Encoding UTF8
    Write-Success "build.gradle.kts patch complete"
    Write-Warning "Review changes and adjust manually if needed."
}

# Create Fastfile.playstore
function Create-Fastfile {
    Write-Step "Creating Fastfile.playstore..."

    $fastlaneDir = Join-Path $ProjectPath "android\fastlane"
    $fastfilePath = Join-Path $fastlaneDir "Fastfile.playstore"
    $templatePath = Join-Path $templateDir "Fastfile.playstore.template"

    if (-not (Test-Path $fastlaneDir)) {
        New-Item -ItemType Directory -Path $fastlaneDir -Force | Out-Null
    }

    if (Test-Path $fastfilePath) {
        Copy-Item $fastfilePath "$fastfilePath.bak" -Force
        Write-Warning "Existing Fastfile.playstore backed up: $fastfilePath.bak"
    }

    # 템플릿 파일 사용 (Bash 스크립트와 동일한 방식)
    if (Test-Path $templatePath) {
        $content = Get-Content $templatePath -Raw -Encoding UTF8
        $content = $content -replace '\{\{APPLICATION_ID\}\}', $ApplicationId
        Set-Content $fastfilePath $content -Encoding UTF8
        Write-Info "Created from template: $templatePath"
    } else {
        # fallback: 템플릿이 없을 경우 기본 내용으로 생성
        Write-Warning "Template not found: $templatePath"
        Write-Warning "Creating with default content..."

        $content = @'
# Fastfile.playstore
# This file is used by GitHub Actions workflow for Play Store deployment

default_platform(:android)

platform :android do
  desc "Deploy to Play Store Internal Testing"
  lane :deploy_internal do
    aab_path = ENV["AAB_PATH"] || "../build/app/outputs/bundle/release/app-release.aab"

    # ⚠️ release_status 설정 가이드:
    #   - "draft": 앱이 Play Console에서 아직 한 번도 출시되지 않은 경우 (신규 앱)
    #   - "completed": 앱이 이미 Play Console에서 검토 완료되어 활성화된 경우
    # 신규 앱은 반드시 "draft"로 시작해야 합니다.
    upload_to_play_store(
      track: 'internal',
      aab: aab_path,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: 'draft'  # 승인 후: 'completed'로 변경
    )
  end

  desc "Deploy to Play Store Production"
  lane :deploy_production do
    aab_path = ENV["AAB_PATH"] || "../build/app/outputs/bundle/release/app-release.aab"

    upload_to_play_store(
      track: 'production',
      aab: aab_path,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: 'draft'  # 승인 후: 'completed'로 변경
    )
  end
end
'@
        Set-Content $fastfilePath $content -Encoding UTF8
    }

    Write-Success "Fastfile.playstore created successfully: $fastfilePath"
    Write-Info "  -> GitHub Actions workflow will use this file directly"
}

# Create Gemfile
function Create-Gemfile {
    Write-Step "Creating Gemfile..."
    
    $gemfilePath = Join-Path $ProjectPath "android\Gemfile"
    
    if (Test-Path $gemfilePath) {
        Copy-Item $gemfilePath "$gemfilePath.bak" -Force
        Write-Warning "Existing Gemfile backed up: $gemfilePath.bak"
    }
    
    $content = @'
source "https://rubygems.org"

gem "fastlane"
'@
    
    Set-Content $gemfilePath $content -Encoding UTF8
    Write-Success "Gemfile created successfully: $gemfilePath"
}

# Summary
function Show-Summary {
    Write-Host ""
    Write-Host "================================================================" -ForegroundColor Cyan
    Write-Host "          Android Play Store Setup Complete!             " -ForegroundColor Green
    Write-Host "================================================================" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "Wizard-First Architecture" -ForegroundColor Yellow
    Write-Host "  All configuration is complete. Workflows will use these files as-is."
    Write-Host ""
    Write-Host "Created/Modified Files:" -ForegroundColor Cyan
    Write-Host "  OK android/.gitignore                    (.gitignore update)"
    Write-Host "  OK android/app/keystore/key.jks         (Keystore created)"
    Write-Host "  OK android/key.properties               (Signing info)"
    Write-Host "  OK android/app/build.gradle.kts         (Signing config patched)"
    Write-Host "  OK android/fastlane/Fastfile.playstore  (Play Store upload)"
    Write-Host "  OK android/Gemfile                      (Fastlane dependencies)"
    Write-Host ""
    Write-Host "Configuration:" -ForegroundColor Cyan
    Write-Host "  - Application ID: $ApplicationId"
    Write-Host "  - Key Alias: $KeyAlias"
    Write-Host "  - Keystore Validity: $ValidityDays days"
    Write-Host ""
    Write-Host "Build Pipeline:" -ForegroundColor Cyan
    Write-Host "  1. flutter build appbundle (Generate AAB)"
    Write-Host "  2. fastlane deploy_internal (Use Fastfile.playstore)"
    Write-Host ""
    Write-Host "Next Steps:" -ForegroundColor Yellow
    Write-Host "  1. Set up GitHub Secrets:"
    Write-Host "     - RELEASE_KEYSTORE_BASE64 (base64 encode keystore file)"
    Write-Host "       Windows: [Convert]::ToBase64String([IO.File]::ReadAllBytes('android\app\keystore\key.jks'))"
    Write-Host "       Linux/Mac: base64 -i android/app/keystore/key.jks"
    Write-Host "     - RELEASE_KEYSTORE_PASSWORD: $StorePassword"
    Write-Host "     - RELEASE_KEY_ALIAS: $KeyAlias"
    Write-Host "     - RELEASE_KEY_PASSWORD: $KeyPassword"
    Write-Host ""
    Write-Host "  2. Commit additional changes (if needed):"
    Write-Host "     git add ."
    Write-Host "     git commit -m `"chore: Android Play Store deployment setup`""
    Write-Host "     (Note: .gitignore was already auto-committed)"
    Write-Host ""
    Write-Host "  3. Push to deploy branch to test build"
    Write-Host ""
    Write-Host "================================================================" -ForegroundColor Cyan
}

# Main execution
Write-Host ""
Write-Host "================================================================" -ForegroundColor Cyan
Write-Host "       Flutter Android Play Store Setup Script               " -ForegroundColor Cyan
Write-Host "================================================================" -ForegroundColor Cyan
Write-Host ""

Write-Host "Project path: $ProjectPath" -ForegroundColor Blue
Write-Host "Application ID: $ApplicationId" -ForegroundColor Blue
Write-Host "Key Alias: $KeyAlias" -ForegroundColor Blue
Write-Host "Validity: $ValidityDays days" -ForegroundColor Blue
Write-Host ""

Validate-Parameters
$templateDir = Get-TemplateDirectory
$gitignoreUpdated = Update-Gitignore
Commit-GitignoreChanges -GitignoreUpdated $gitignoreUpdated
Create-Keystore
Create-KeyProperties
Patch-BuildGradle
Create-Fastfile
Create-Gemfile
Show-Summary

Write-Host ""
Write-Host "Setup completed successfully!" -ForegroundColor Green
Write-Host ""

