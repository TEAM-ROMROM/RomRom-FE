# 프로젝트 컨텍스트

## 주요 디자인 요소
- 기본 배경색: AppColors.primaryBlack (#131419)
- 강조색: AppColors.primaryYellow (#FFC300)

## 주요 파일 관계
- AppColors: 색상 상수 정의
- AppTheme: 앱 전체 테마 및 텍스트 스타일 정의
- AppIcons: 커스텀 아이콘 정의
- AppUrls: API 엔드포인트 정의

## 핵심 코드 작성 규칙

### 기본 스타일
- 색상 투명도 설정 시 withOpacity 대신 withValues(alpha: 값) 사용
- 색상 코드 직접 사용 금지, 항상 AppColors에 정의된 색상 상수 사용
- 불필요한 설명 주석 제거하여 코드 가독성 향상
- 새로운 패턴이나 규칙 발견 시 이 가이드라인에 지속적으로 추가
- 디버깅 출력 시 print 대신 debugPrint 사용
- 린트 경고는 가능한 모두 해결, 불가피한 경우에만 ignore 주석 사용

### 비동기 코드 작성 규칙
- 비동기 작업 후 context 사용 시 반드시 context.mounted 확인
- 비동기 갭 이후 UI 업데이트가 필요한 경우, 모든 데이터를 먼저 준비한 후 한 번에 처리
- Navigator나 기타 context 의존적 작업은 항상 mounted 상태 확인 후 실행

### 린트 경고 해결 방법
- 모든 위젯에 가능한 const 키워드 사용
- 동적 값과 함께 사용할 수 없는 경우 파일 상단에 ignore 주석 추가
- 항상 true가 되는 조건문 제거
- null 체크가 필요한 경우 null-aware 연산자 활용

## 주석 및 문서화 가이드

### 주석 스타일
- 한글 주석 사용하되 팀원의 이해를 돕는 경우에만 추가
- 간결하고 핵심만 담은 주석 작성
- 클래스는 한 줄로 요약하고 기능 설명
- 속성이나 필드는 간결하게 한 줄로 설명
- 인라인 주석을 선호하여 코드 우측에 짧게 설명
- TODO나 FIXME는 간결하게 핵심만 설명

### 유지해야 할 주석
- 코드 블록의 목적을 명확히 설명하는 주석
- 명사 키워드로 표현된 간결한 설명
- 조건문이나 분기 처리의 의도를 설명하는 주석

### 제거해야 할 주석
- 코드 자체로 명확한 내용을 반복하는 주석
- 명백한 코드에 대한 불필요한 설명 주석

### 디버깅 로그 형식
- 모든 디버깅 출력은 debugPrint 사용
- 명확한 컨텍스트와 값을 포함하는 형식으로 작성
- 카테고리를 접두어로 사용하여 로그 구분
- 개발 중에만 사용하고 배포 전 제거하거나 조건부 출력
- 필요한 경우 kDebugMode 조건부 로깅 사용

## 네이밍 규칙

### 변수명 규칙
- 일반적이거나 모호한 이름 대신 구체적이고 명확한 변수명 사용
- Boolean 변수는 항상 is 접두사 사용
- 복수형 표현 시 List 접미사 대신 s 사용
- 약어 사용 자제, 특히 잘 알려지지 않은 약어 피하기
- 함수명은 동사로 시작하여 행동을 명확하게 표현
- 속성 접근자나 변환 함수는 get 접두사 사용

## 스크린 구현 가이드라인

### 파일 구성 및 네이밍
- 스크린 파일명은 snake_case로 작성하고 항상 _screen 접미사 사용
- 스크린 클래스명은 PascalCase로 작성
- 중첩 화면은 디렉토리를 만들고 관련 화면들을 그룹화

### 스크린 구조 및 레이아웃
- 모든 스크린은 Scaffold 위젯 사용
- 하단 네비게이션바가 있는 경우 extendBody true 설정
- 키보드 표시 시 자동 조정이 필요한 경우 resizeToAvoidBottomInset true 설정
- 시스템 네비게이션바와 겹침 방지를 위해 SafeArea 적절히 사용
- 화면 패딩은 일관되게 유지하고 가로 24, 세로 16 기준 사용
- 스크롤 가능한 화면은 SingleChildScrollView 또는 ListView 사용

### 상태 관리 및 로직 분리
- 스크린 위젯은 StatefulWidget으로 구현
- 복잡한 상태나 비즈니스 로직은 별도 클래스나 서비스로 분리
- 상태 변수는 클래스 상단에 명확한 이름으로 선언
- 상태 초기화는 initState에서 수행
- 컨텍스트 의존적 초기화는 didChangeDependencies에서 수행
- 스크린이 사용하는 리소스 해제는 dispose 메서드에서 처리

### 위젯 분리 및 재사용
- 복잡한 UI 요소는 별도 위젯으로 분리
- 반복되는 UI 패턴은 재사용 가능한 위젯으로 추출
- 화면별 전용 위젯은 화면 파일 내에서 언더스코어 접두사 사용
- 다른 화면에서도 사용될 위젯은 widgets/common 디렉토리로 분리

### 비동기 처리
- 로딩 상태는 isLoading 변수로 관리하고 UI에 반영
- 에러 처리는 try-catch 블록 사용하고 적절한 에러 메시지 표시
- 비동기 상태는 로딩, 성공, 에러 세 가지 모두 처리
- 비동기 연산 후 화면 업데이트 시 위젯이 여전히 트리에 있는지 확인 후 setState 호출

### 화면 적응형 처리
- 모든 크기 단위는 ScreenUtil 확장 사용
- 화면 너비와 높이는 MediaQuery로 동적 계산
- 안드로이드 시스템 네비게이션바 처리를 위한 패딩 적용
- 모바일 방향 변경 대응은 OrientationBuilder 사용

### 성능 최적화
- 무거운 연산은 UI 스레드가 아닌 별도 격리자에서 처리
- 대용량 리스트는 ListView.builder로 구현
- 불필요한 빌드 방지를 위해 const 생성자 최대한 활용
- 이미지는 적절한 크기로 최적화하여 사용
- 복잡한 애니메이션은 AnimationController로 최적화

### 네비게이션 처리
- 화면 이동은 NavigationTypes enum 활용
- 뒤로가기 처리가 필요한 경우 WillPopScope 위젯 사용
- 깊은 중첩 페이지에서는 Navigator.popUntil 활용

## 스크롤 연동 헤더 구현 패턴

### 스크롤 연동 헤더 구조
- NestedScrollView와 SliverAppBar를 활용한 스크롤 연동 헤더 구현
- 확장형 헤더와 축소형 헤더를 분리하여 스크롤에 따른 전환 효과 구현
- headerSliverBuilder에서 헤더 위젯들을 정의하고 body에서 스크롤 가능한 콘텐츠 구성

### 스크롤 감지 및 애니메이션
- ScrollController를 활용한 스크롤 위치 감지
- 스크롤 리스너를 통해 특정 오프셋에서 상태 변경
- 스크롤 상태에 따른 헤더 스타일 동적 변경

### 헤더 전환 효과
- 스크롤에 따른 투명도 변화로 자연스러운 전환 구현
- innerBoxIsScrolled 매개변수를 활용한 스크롤 상태 감지
- 배경색과 elevation 값을 동적으로 조정

### 플로팅 액션 버튼 처리
- 스크롤 방향에 따른 FAB 숨김과 표시 처리
- ScrollDirection을 활용한 스크롤 방향 감지
- AnimatedOpacity를 통한 부드러운 전환 애니메이션

## 문서 작성 및 설명 형식 가이드

### 텍스트 형식 규칙
- 코드 예시보다는 텍스트 설명을 우선으로 작성
- 복잡한 코드 블록은 최소화하고 핵심 개념만 간단히 제시
- 전체적인 흐름과 개념을 이해할 수 있도록 줄글 형태로 설명
- 필요한 정보는 누락 없이 포함하되 가독성을 위해 간결하게 작성
- 기술적 내용도 개발자가 쉽게 이해할 수 있는 자연스러운 문장으로 표현

### 가이드라인 업데이트 방식
- 새로운 내용 추가 시 기존 텍스트 중심의 설명 형식을 유지
- 코드보다는 개념과 원칙 중심으로 내용 구성
- 실용적인 가이드가 되도록 개발 시 실제로 참고할 수 있는 형태로 작성
- 지속적으로 내용을 개선하되 전체적인 일관성 유지

## 중요 참고사항
- 항상 답변하기 전에 전체적인 Plan을 먼저 수립하고 해당 Task에 대해 잘 처리할 것
- 이 파일을 참고하면서 답변을 제공하되, 요구사항과 이 문서의 내용이 다르거나 추가로 참고할 만한 내용이 있으면 자동으로 이 가이드라인에 추가하여 지속적으로 개선할 것
- 의미 없는 내용은 제거하고 참고할 만한 내용을 추가하여 더 나은 답변을 위한 자료로 활용할 것
- 모든 설명은 텍스트 중심으로 작성하되 필요한 정보는 누락 없이 포함할 것
- 가이드라인 업데이트 시에도 동일한 텍스트 설명 형식을 유지하여 일관성 확보할 것